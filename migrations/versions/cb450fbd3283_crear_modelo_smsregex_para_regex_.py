"""crear modelo SMSRegex para regex especificos de SMS

Revision ID: cb450fbd3283
Revises: ef7bda1b1e3c
Create Date: 2025-11-29 16:36:44.580161

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'cb450fbd3283'
down_revision = 'ef7bda1b1e3c'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    # Verificar si la tabla sms_regex ya existe
    from sqlalchemy import inspect
    conn = op.get_bind()
    inspector = inspect(conn)
    tables = inspector.get_table_names()
    
    # Crear tabla sms_regex solo si no existe
    if 'sms_regex' not in tables:
        op.create_table('sms_regex',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(length=200), nullable=False),
        sa.Column('pattern', sa.String(length=500), nullable=False),
        sa.Column('enabled', sa.Boolean(), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=True),
        sa.Column('updated_at', sa.DateTime(), nullable=True),
        sa.PrimaryKeyConstraint('id')
        )
    
    # Modificar tabla sms_config_regex
    # Obtener información de los constraints existentes
    from sqlalchemy.engine import reflection
    conn = op.get_bind()
    inspector = reflection.Inspector.from_engine(conn)
    
    # Obtener todos los foreign keys de la tabla
    fks = inspector.get_foreign_keys('sms_config_regex')
    fk_names_to_drop = []
    for fk in fks:
        # Buscar el constraint que referencia a regexes.id
        # constrained_columns es una lista de strings en SQLite
        constrained_cols = fk.get('constrained_columns', [])
        if fk.get('referred_table') == 'regexes' and 'regex_id' in constrained_cols:
            if fk.get('name'):
                fk_names_to_drop.append(fk['name'])
    
    with op.batch_alter_table('sms_config_regex', schema=None) as batch_op:
        # Agregar columna nullable primero
        batch_op.add_column(sa.Column('sms_regex_id', sa.Integer(), nullable=True))
        
        # Eliminar índice antiguo
        try:
            batch_op.drop_index('ix_sms_config_regex_ids')
        except:
            pass
        
        # Eliminar foreign keys que referencian a regexes
        for fk_name in fk_names_to_drop:
            try:
                batch_op.drop_constraint(fk_name, type_='foreignkey')
            except:
                pass
        
        # Eliminar columna regex_id
        try:
            batch_op.drop_column('regex_id')
        except:
            pass
        
        # Crear nuevo índice
        batch_op.create_index('ix_sms_config_regex_ids', ['sms_config_id', 'sms_regex_id'], unique=False)
        
        # Crear foreign key nuevo
        batch_op.create_foreign_key('fk_sms_config_regex_sms_regex_id', 'sms_regex', ['sms_regex_id'], ['id'], ondelete='CASCADE')
        
        # Hacer la columna NOT NULL ahora que está vacía
        batch_op.alter_column('sms_regex_id', nullable=False)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('sms_config_regex', schema=None) as batch_op:
        # Agregar columna regex_id nullable primero
        batch_op.add_column(sa.Column('regex_id', sa.INTEGER(), nullable=True))
        # Eliminar foreign key y índice nuevos
        batch_op.drop_constraint('fk_sms_config_regex_sms_regex_id', type_='foreignkey')
        batch_op.drop_index('ix_sms_config_regex_ids')
        # Eliminar columna sms_regex_id
        batch_op.drop_column('sms_regex_id')
        # Crear índice y foreign key antiguos
        batch_op.create_index('ix_sms_config_regex_ids', ['sms_config_id', 'regex_id'], unique=False)
        batch_op.create_foreign_key('fk_sms_config_regex_regex_id', 'regexes', ['regex_id'], ['id'], ondelete='CASCADE')
        # Hacer NOT NULL
        batch_op.alter_column('regex_id', nullable=False)

    op.drop_table('sms_regex')
    # ### end Alembic commands ###
